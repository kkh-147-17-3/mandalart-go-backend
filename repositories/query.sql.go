// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package repositories

import (
	"context"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users(social_id, social_provider)
VALUES($1,$2)
RETURNING id
`

type CreateUserParams struct {
	SocialID       *string `json:"socialId"`
	SocialProvider *string `json:"socialProvider"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int32, error) {
	row := q.db.QueryRow(ctx, createUser, arg.SocialID, arg.SocialProvider)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getLatestSheetByOwnerId = `-- name: GetLatestSheetByOwnerId :one
SELECT id, owner_id, name, created_at, modified_at FROM sheets WHERE owner_id = $1 ORDER BY id DESC LIMIT 1
`

func (q *Queries) GetLatestSheetByOwnerId(ctx context.Context, ownerID *int32) (Sheet, error) {
	row := q.db.QueryRow(ctx, getLatestSheetByOwnerId, ownerID)
	var i Sheet
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}

const getLatestSheetWithMainCellsByOwnerId = `-- name: GetLatestSheetWithMainCellsByOwnerId :many
SELECT sheets.id, sheets.name, cells.id "cell_id", cells.color, cells.goal, cells.is_completed FROM sheets
JOIN cells ON sheets.id = cells.sheet_id AND cells.step = 2
WHERE sheets.id = (
    SELECT id FROM sheets WHERE sheets.owner_id = $1 ORDER BY id DESC LIMIT 1
)
`

type GetLatestSheetWithMainCellsByOwnerIdRow struct {
	ID          int32   `json:"id"`
	Name        *string `json:"name"`
	CellID      int32   `json:"cellId"`
	Color       *string `json:"color"`
	Goal        *string `json:"goal"`
	IsCompleted bool    `json:"isCompleted"`
}

func (q *Queries) GetLatestSheetWithMainCellsByOwnerId(ctx context.Context, ownerID *int32) ([]GetLatestSheetWithMainCellsByOwnerIdRow, error) {
	rows, err := q.db.Query(ctx, getLatestSheetWithMainCellsByOwnerId, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestSheetWithMainCellsByOwnerIdRow
	for rows.Next() {
		var i GetLatestSheetWithMainCellsByOwnerIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CellID,
			&i.Color,
			&i.Goal,
			&i.IsCompleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMainCellsBySheetId = `-- name: GetMainCellsBySheetId :many
SELECT id, sheet_id, goal, color, step, "order", parent_id, is_completed, created_at, modified_at, owner_id FROM cells WHERE sheet_id = $1 AND step = 1
`

func (q *Queries) GetMainCellsBySheetId(ctx context.Context, sheetID *int32) ([]Cell, error) {
	rows, err := q.db.Query(ctx, getMainCellsBySheetId, sheetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cell
	for rows.Next() {
		var i Cell
		if err := rows.Scan(
			&i.ID,
			&i.SheetID,
			&i.Goal,
			&i.Color,
			&i.Step,
			&i.Order,
			&i.ParentID,
			&i.IsCompleted,
			&i.CreatedAt,
			&i.ModifiedAt,
			&i.OwnerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTodosByCellId = `-- name: GetTodosByCellId :many
SELECT id, owner_id, cell_id, content, created_at, modified_at FROM todos WHERE cell_id = $1
`

func (q *Queries) GetTodosByCellId(ctx context.Context, cellID *int32) ([]Todo, error) {
	rows, err := q.db.Query(ctx, getTodosByCellId, cellID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Todo
	for rows.Next() {
		var i Todo
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.CellID,
			&i.Content,
			&i.CreatedAt,
			&i.ModifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserBySocialProviderInfo = `-- name: GetUserBySocialProviderInfo :one
SELECT id, social_id, social_provider FROM users WHERE social_id = $1 AND social_provider = $2 LIMIT 1
`

type GetUserBySocialProviderInfoParams struct {
	SocialID       *string `json:"socialId"`
	SocialProvider *string `json:"socialProvider"`
}

func (q *Queries) GetUserBySocialProviderInfo(ctx context.Context, arg GetUserBySocialProviderInfoParams) (User, error) {
	row := q.db.QueryRow(ctx, getUserBySocialProviderInfo, arg.SocialID, arg.SocialProvider)
	var i User
	err := row.Scan(&i.ID, &i.SocialID, &i.SocialProvider)
	return i, err
}
